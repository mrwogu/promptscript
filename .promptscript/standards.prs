# Code standards and conventions

@standards {
  typescript: [
    "Strict mode enabled",
    "Never use `any` type - use `unknown` with type guards",
    "Use `unknown` with type guards instead of any",
    "Prefer `interface` for object shapes",
    "Use `type` for unions and intersections",
    "Named exports only, no default exports",
    "Explicit return types on public functions"
  ]

  naming: [
    "Files: `kebab-case.ts`",
    "Classes: `PascalCase`",
    "Interfaces: `PascalCase`",
    "Functions: `camelCase`",
    "Variables: `camelCase`",
    "Constants: `UPPER_SNAKE_CASE`"
  ]

  errors: [
    "Use custom error classes extending `PSError`",
    "Always include location information",
    "Provide actionable error messages"
  ]

  testing: [
    "Test files: `*.spec.ts` next to source",
    "Follow AAA (Arrange, Act, Assert) pattern",
    "Framework: Vitest",
    "Target >90% coverage for libraries",
    "Use fixtures for parser tests"
  ]

  git: {
    format: "Conventional Commits"
    reference: "https://www.conventionalcommits.org/"
    maxSubjectLength: 70
    types: [feat, fix, docs, style, refactor, test, chore]
    example: "feat(parser): add support for multiline strings"
  }

  config: {
    eslint: "inherit from eslint.base.config.cjs"
    viteRoot: "__dirname (not import.meta.dirname)"
  }

  diagrams: {
    format: "Mermaid (exception: packages/*/README.md must use ASCII art because npm does not render Mermaid)"
    types: [flowchart, sequence, class, state, ER, gantt, pie]
    example: """
      ```mermaid
      flowchart LR
        A[Input] --> B[Process] --> C[Output]
      ```
    """
  }

  documentation: {
    verifyBefore: "review README.md and docs/ before changes"
    verifyAfter: "update docs if behavior changes"
    codeExamples: "keep accurate"
    syncWithCode: "after modifying any function, verify it is documented - if not, add documentation; if documented, ensure it reflects current behavior"
    noVaporware: "never document features that don't exist or don't work - ideas and future plans go to ROADMAP.md only"
  }

  workflow: {
    branchStrategy: "gitflow"
    newTask: """
      When starting a new task while on main branch:
      1. Create feature branch: git checkout -b feat/<task-name> or fix/<task-name>
      2. Make changes with atomic commits (Conventional Commits format)
      3. Run full verification pipeline before pushing
      4. Push branch: git push -u origin <branch-name>
      5. Create PR: gh pr create --fill
      6. Monitor CI: gh pr checks --watch
      7. If checks fail, fix issues and push again
      8. Wait for all checks to pass before considering work complete
    """
    prMonitoring: "use `gh pr checks --watch` to monitor CI status; do not consider work done until all checks pass"
  }
}
