---
description: "Project-specific rules"
alwaysApply: true
---

<!-- PromptScript 2026-01-30T14:00:10.623Z - do not edit -->

You are working on PromptScript at PromptScript.

Tech stack: typescript, Node.js 20+, Nx, pnpm workspaces

## Architecture

  The project is organized as a monorepo with these packages:

  ```mermaid
  flowchart TB
    subgraph packages
      core[core - Types, errors, utilities]
      parser[parser - Chevrotain-based parser]
      resolver[resolver - Inheritance & import resolution]
      validator[validator - AST validation rules]
      compiler[compiler - Pipeline orchestration]
      formatters[formatters - Output formatters]
      cli[cli - Command-line interface]
    end

    cli --> compiler
    cli --> resolver
    compiler --> resolver
    compiler --> validator
    compiler --> formatters
    resolver --> parser
    parser --> core
    resolver --> core
    validator --> core
    formatters --> core
  ```

  ## Key Libraries

  - Parser: Chevrotain
  - CLI: Commander.js
  - Testing: Vitest
  - Linting: ESLint + Prettier

## Project Structure (Library)
  - src/ - Source code
  - src/index.ts - Public API exports
  - src/types/ - TypeScript type definitions
  - src/__tests__/ - Unit tests
  - dist/ - Compiled output

  ## Project Structure (Monorepo)
  - packages/ - Individual packages
  - packages/*/src/ - Package source
  - packages/*/package.json - Package manifest

Code style:
- Strict mode enabled
- Never use `any` type - use `unknown` with type guards
- Use `unknown` with type guards instead of any
- Prefer `interface` for object shapes
- Use `type` for unions and intersections
- Named exports only, no default exports
- Explicit return types on public functions
- Files: `kebab-case.ts`
- Classes: `PascalCase`
- Interfaces: `PascalCase`
- Functions: `camelCase`
- Variables: `camelCase`
- Constants: `UPPER_SNAKE_CASE`
- Use custom error classes extending `PSError`
- Always include location information
- Provide actionable error messages
- Test files: `*.spec.ts` next to source
- Follow AAA (Arrange, Act, Assert) pattern
- Framework: Vitest
- Target >90% coverage for libraries
- Use fixtures for parser tests
- Meaningful coverage
- Isolated tests
- Descriptive naming
- branchStrategy: gitflow
- newTask: When starting a new task while on main branch:
      1. Create feature branch: git checkout -b feat/<task-name> or fix/<task-name>
      2. Make changes with atomic commits (Conventional Commits format)
      3. Run full verification pipeline before pushing
      4. Push branch: git push -u origin <branch-name>
      5. Create PR: gh pr create --fill
      6. Monitor CI: gh pr checks --watch
      7. If checks fail, fix issues and push again
      8. Wait for all checks to pass before considering work complete
- prMonitoring: use `gh pr checks --watch` to monitor CI status; do not consider work done until all checks pass
- Format: conventional commits
- Scope: atomic changes
- Message: imperative mood
- Main: always deployable
- Feature: feature/description
- Bugfix: fix/description
- Release: release/version
- Strict isolation
- Naming: describe behavior, not implementation
- Meaningful coverage
- Fast speed
- Scope: component boundaries
- Setup: clean state
- Teardown: no side effects
- Focus: critical user journeys
- Stability: no flaky tests
- Data: isolated test data
- Descriptive naming
- Single responsibility functions
- Comments: explain why, not what
- Consistent formatting
- Input validation required
- Output encoding required
- Verify before trust for authentication
- Check authorization at every layer
- Loose coupling
- High cohesion
- Explicit dependencies
- Never hardcoded
- Never logged
- Prevent exposure
- Audit regularly
- Pin versions
- Use trusted sources only
- Professional tone
- Clear format
- Citations when applicable
- Show work
- Acknowledge uncertainty
- style: named exports only
- barrel: use index.ts for public API
- internal: prefix with underscore or use /internal
- changelog: maintain CHANGELOG.md
- semver: follow semantic versioning
- types: include TypeScript declarations

Git Commits:
- format: Conventional Commits
- reference: https://www.conventionalcommits.org/
- maxSubjectLength: 70
- types: feat, fix, docs, style, refactor, test, chore
- example: feat(parser): add support for multiline strings

Config:
- eslint: inherit from eslint.base.config.cjs
- viteRoot: __dirname (not import.meta.dirname)

Commands:
/review - Review code for quality, type safety, and best practices
/test - 
/test-unit - 
/test-integration - 
/test-coverage - 
/test-e2e - 
/build - 
/newpkg - 
/quality - 
/refactor - 
/security-review - 
/threat-model - 
/cli - 
/export - 
/type - 

Development Commands:
```bash
  pnpm install              # Install dependencies
  pnpm nx build <pkg>       # Build package
  pnpm nx test <pkg>        # Run tests
  pnpm nx lint <pkg>        # Lint code
  pnpm nx run-many -t test  # Test all packages
  pnpm nx graph             # View dependency graph
  pnpm prs compile          # Compile .prs files (uses local dev version)
  ```

Post-Work Verification:
(MANDATORY)

  After completing ANY code changes, run ALL steps in order:
  ```bash
  pnpm run format           # 1. Format code with Prettier
  pnpm run lint             # 2. Check for linting errors
  pnpm run typecheck        # 3. Verify TypeScript types
  pnpm run test             # 4. Run all tests
  pnpm prs validate --strict  # 5. Validate .prs files
  pnpm schema:check         # 6. Verify JSON schemas are current
  ```

Documentation:
- review README.md and docs/ before changes
- update docs if behavior changes
- keep accurate
- after modifying any function, verify it is documented - if not, add documentation; if documented, ensure it reflects current behavior
- never document features that don't exist or don't work - ideas and future plans go to ROADMAP.md only

Diagrams:
- Use Mermaid (exception: packages/*/README.md must use ASCII art because npm does not render Mermaid)
- Types: flowchart, sequence, class, state, ER, gantt, pie

Never:
- Never use `any` type - use `unknown` with type guards
- Never use default exports - only named exports
- Never commit without tests
- Never skip error handling
- Never leave TODO without issue reference
- Never create packages manually - use Nx generators (nx g @nx/js:lib)
- Never create custom ESLint rules in package configs - extend base config
- Never use `import.meta.dirname` in vite/vitest configs - use `__dirname`
- Never reference line numbers in test names or comments
- Never make code changes without verifying documentation consistency
- Never document features that don't exist or don't work - ideas go to ROADMAP.md
- Never skip the full verification pipeline (format, lint, typecheck, test, validate, schema:check)
- Never consider work complete until all CI checks pass (use `gh pr checks --watch`)
- Never commit directly to main - always use feature branches
- Never commit directly to main/master
- Never force push to shared branches
- Never commit secrets or credentials
- Never create commits with unrelated changes
- Never test implementation details
- Never write tests that depend on execution order
- Never share mutable state between tests
- Never ignore flaky tests
- Never sacrifice readability for micro-optimizations
- Never leave dead code or commented-out blocks
- Never use magic numbers without named constants
- Never ignore compiler/linter warnings without justification
- Never generate code with known vulnerabilities
- Never expose secrets, credentials, or API keys
- Never disable security features without explicit user consent
- Never trust user input without validation
- Never use deprecated or insecure cryptographic functions
- Never generate harmful, illegal, or unethical content
- Never pretend to have capabilities you don't have
- Always clarify when unsure rather than guessing
- Never use default exports - named exports only
- Never expose internal implementation details
- Never break semver without major version bump
- Never publish without type declarations
