---
description: "Project-specific rules"
alwaysApply: true
---

You are working on PromptScript at PromptScript.

Tech stack: typescript, Node.js 20+, Nx, pnpm workspaces

## Architecture

  The project is organized as a monorepo with these packages:

  ```mermaid
  flowchart TB
    subgraph packages
      core[core - Types, errors, utilities]
      parser[parser - Chevrotain-based parser]
      resolver[resolver - Inheritance & import resolution]
      validator[validator - AST validation rules]
      compiler[compiler - Pipeline orchestration]
      formatters[formatters - Output formatters]
      cli[cli - Command-line interface]
    end

    cli --> compiler
    compiler --> parser
    compiler --> resolver
    compiler --> validator
    compiler --> formatters
    parser --> core
    resolver --> core
    validator --> core
    formatters --> core
  ```

  ## Key Libraries

  - Parser: Chevrotain
  - CLI: Commander.js
  - Testing: Vitest
  - Linting: ESLint + Prettier

## Backend Best Practices
  - Design APIs with clear contracts
  - Implement proper error handling
  - Use connection pooling for databases
  - Apply rate limiting and throttling
  - Log appropriately for debugging

## Project Structure
  - src/controllers/ - Request handlers
  - src/services/ - Business logic
  - src/repositories/ - Data access
  - src/middleware/ - Express middleware
  - src/utils/ - Utility functions
  - src/types/ - TypeScript definitions

Code style:
- useUnknown: with type guards instead of any
- interfaces: for object shapes
- types: for unions and intersections
- exports: named only, no default exports
- returnTypes: explicit on public functions
- files: kebab-case.ts
- classes: PascalCase
- interfaces: PascalCase
- functions: camelCase
- variables: camelCase
- constants: UPPER_SNAKE_CASE
- customClasses: extend PSError
- messages: actionable
- filePattern: *.spec.ts next to source
- pattern: AAA (Arrange, Act, Assert)
- fixtures: for parser tests
- framework: vitest

Git Commits:
- format: Conventional Commits
- reference: https://www.conventionalcommits.org/
- maxSubjectLength: 70
- types: feat, fix, docs, style, refactor, test, chore
- example: feat(parser): add support for multiline strings

Config:
- eslint: inherit from eslint.base.config.cjs
- viteRoot: __dirname (not import.meta.dirname)

Commands:
/review - Review code for quality, type safety, and best practices
/test - Write unit tests using:
/build - Run verification commands:
/newpkg - Generate new package with Nx:
/quality - Review code for quality improvements
/refactor - Suggest refactoring opportunities
/security-review - Review code for security vulnerabilities
/threat-model - Analyze potential security threats
/api - Design or implement an API endpoint
/query - Write or optimize database queries
/auth - Implement authentication/authorization
/scale - Suggest scalability improvements
/endpoint - Create an API endpoint
/service - Create a service class
/middleware - Create Express middleware

Documentation:
- review README.md and docs/ before changes
- update docs if behavior changes
- keep accurate

Diagrams:
- Use Mermaid
- Types: flowchart, sequence, class, state, ER, gantt, pie

Never:
- Never use `any` type - use `unknown` with type guards
- Never use default exports - only named exports
- Never commit without tests
- Never skip error handling
- Never leave TODO without issue reference
- Never create packages manually - use Nx generators (nx g @nx/js:lib)
- Never create custom ESLint rules in package configs - extend base config
- Never use `import.meta.dirname` in vite/vitest configs - use `__dirname`
- Never use ASCII art diagrams - always use Mermaid
- Never reference line numbers in test names or comments
- Never make code changes without verifying documentation consistency
- Never commit directly to main/master
- Never force push to shared branches
- Never commit secrets or credentials
- Never create commits with unrelated changes
- Never test implementation details
- Never write tests that depend on execution order
- Never share mutable state between tests
- Never ignore flaky tests
- Never sacrifice readability for micro-optimizations
- Never leave dead code or commented-out blocks
- Never use magic numbers without named constants
- Never ignore compiler/linter warnings without justification
- Never generate code with known vulnerabilities
- Never expose secrets, credentials, or API keys
- Never disable security features without explicit user consent
- Never trust user input without validation
- Never use deprecated or insecure cryptographic functions
- Never generate harmful, illegal, or unethical content
- Never pretend to have capabilities you don't have
- Always clarify when unsure rather than guessing
- Never expose internal errors to clients
- Never store passwords in plain text
- Never trust client-side data without validation
