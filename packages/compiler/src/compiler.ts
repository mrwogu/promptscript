import type { PSError } from '@promptscript/core';
import { FormatterRegistry } from '@promptscript/formatters';
import { Resolver, type ResolvedAST } from '@promptscript/resolver';
import { Validator, type ValidatorConfig } from '@promptscript/validator';
import type {
  CompilerOptions,
  CompileResult,
  CompileStats,
  CompileError,
  Formatter,
  FormatterOutput,
  FormatterConstructor,
  TargetConfig,
  WatchOptions,
  Watcher,
} from './types.js';

/**
 * Internal representation of a loaded formatter with its config.
 */
interface LoadedFormatter {
  formatter: Formatter;
  config?: TargetConfig;
}

/**
 * Generate marker comment that identifies files generated by PromptScript.
 * Uses HTML comment to be invisible to LLMs and rendered output.
 */
function generateMarker(): string {
  const timestamp = new Date().toISOString();
  return `<!-- PromptScript ${timestamp} - do not edit -->`;
}

/**
 * Add PromptScript marker to output content if not already present.
 * Handles YAML frontmatter by inserting after the closing ---.
 */
function addMarkerToOutput(output: FormatterOutput): FormatterOutput {
  const { content, path } = output;

  // Skip if marker already present (check for the static part)
  if (content.includes('<!-- PromptScript')) {
    return output;
  }

  const marker = generateMarker();

  // Only add to markdown files
  if (!path.endsWith('.md') && !path.endsWith('.mdc')) {
    return output;
  }

  // Check for YAML frontmatter (starts with ---)
  if (content.startsWith('---')) {
    // Find the closing ---
    const closingIndex = content.indexOf('---', 3);
    if (closingIndex !== -1) {
      // Insert marker after frontmatter
      const beforeMarker = content.slice(0, closingIndex + 3);
      const afterMarker = content.slice(closingIndex + 3);
      // Add marker on its own line after frontmatter
      const newContent = `${beforeMarker}\n\n${marker}\n${afterMarker.replace(/^\n+/, '\n')}`;
      return { ...output, content: newContent };
    }
  }

  // No frontmatter - add marker at the beginning (after any title)
  const lines = content.split('\n');
  if (lines[0]?.startsWith('# ')) {
    // Has title - insert after title
    lines.splice(1, 0, '', marker);
  } else {
    // No title - insert at beginning
    lines.unshift(marker, '');
  }
  return { ...output, content: lines.join('\n') };
}

/**
 * Compiler that orchestrates the PromptScript compilation pipeline.
 *
 * Pipeline stages:
 * 1. Resolve - Parse and resolve inheritance/imports
 * 2. Validate - Check AST against validation rules
 * 3. Format - Generate output for target platforms
 *
 * @example
 * ```typescript
 * const compiler = new Compiler({
 *   resolver: { registryPath: './registry' },
 *   validator: { requiredGuards: ['@core/guards/compliance'] },
 *   formatters: [new GitHubFormatter()],
 * });
 *
 * const result = await compiler.compile('./project.prs');
 * if (result.success) {
 *   for (const [outputPath, output] of result.outputs) {
 *     console.log(`Generated: ${outputPath}`);
 *   }
 * }
 * ```
 */
export class Compiler {
  private readonly resolver: Resolver;
  private readonly validator: Validator;
  private readonly loadedFormatters: LoadedFormatter[];

  constructor(private readonly options: CompilerOptions) {
    this.resolver = new Resolver(options.resolver);
    this.validator = new Validator(options.validator);
    this.loadedFormatters = this.loadFormatters(options.formatters);
  }

  /**
   * Compile a PromptScript file through the full pipeline.
   *
   * @param entryPath - Path to the entry file
   * @returns Compilation result with outputs, errors, and stats
   */
  async compile(entryPath: string): Promise<CompileResult> {
    const startTotal = Date.now();
    const stats: CompileStats = {
      resolveTime: 0,
      validateTime: 0,
      formatTime: 0,
      totalTime: 0,
    };

    // Stage 1: Resolve
    const startResolve = Date.now();
    let resolved: ResolvedAST;

    try {
      resolved = await this.resolver.resolve(entryPath);
    } catch (err) {
      stats.resolveTime = Date.now() - startResolve;
      stats.totalTime = Date.now() - startTotal;

      return {
        success: false,
        outputs: new Map(),
        errors: [this.toCompileError(err as Error)],
        warnings: [],
        stats,
      };
    }

    stats.resolveTime = Date.now() - startResolve;

    // Check for resolve errors
    if (resolved.errors.length > 0 || !resolved.ast) {
      stats.totalTime = Date.now() - startTotal;

      return {
        success: false,
        outputs: new Map(),
        errors: resolved.errors.map((e) => this.toCompileError(e)),
        warnings: [],
        stats,
      };
    }

    // Stage 2: Validate
    const startValidate = Date.now();
    const validation = this.validator.validate(resolved.ast);
    stats.validateTime = Date.now() - startValidate;

    // Check for validation errors
    if (!validation.valid) {
      stats.totalTime = Date.now() - startTotal;

      return {
        success: false,
        outputs: new Map(),
        errors: validation.errors.map((e) => this.validationToCompileError(e)),
        warnings: validation.warnings,
        stats,
      };
    }

    // Stage 3: Format
    const startFormat = Date.now();
    const outputs = new Map<string, FormatterOutput>();
    const formatErrors: CompileError[] = [];

    for (const { formatter, config } of this.loadedFormatters) {
      try {
        const formatOptions = this.getFormatOptionsForTarget(formatter.name, config);
        const output = formatter.format(resolved.ast, formatOptions);
        // Use output path as key to support multiple targets with same formatter
        // (e.g., cursor modern + cursor legacy)
        // Add PromptScript marker to all outputs for overwrite detection
        outputs.set(output.path, addMarkerToOutput(output));

        // Also add any additional files (e.g., .cursor/commands/, .github/prompts/)
        if (output.additionalFiles) {
          for (const additionalFile of output.additionalFiles) {
            outputs.set(additionalFile.path, addMarkerToOutput(additionalFile));
          }
        }
      } catch (err) {
        formatErrors.push({
          name: 'FormatterError',
          code: 'PS4000',
          message: `Formatter '${formatter.name}' failed: ${(err as Error).message}`,
        });
      }
    }

    stats.formatTime = Date.now() - startFormat;
    stats.totalTime = Date.now() - startTotal;

    if (formatErrors.length > 0) {
      return {
        success: false,
        outputs,
        errors: formatErrors,
        warnings: validation.warnings,
        stats,
      };
    }

    return {
      success: true,
      outputs,
      errors: [],
      warnings: validation.warnings,
      stats,
    };
  }

  /**
   * Get the configured formatters.
   */
  getFormatters(): readonly Formatter[] {
    return this.loadedFormatters.map((lf) => lf.formatter);
  }

  /**
   * Compile a PromptScript file from a file path.
   * This is an alias for compile() for consistency with the documented API.
   *
   * @param filePath - Path to the PromptScript file
   * @returns Compilation result
   */
  async compileFile(filePath: string): Promise<CompileResult> {
    return this.compile(filePath);
  }

  /**
   * Compile to all registered formatters.
   * Useful when you want to ensure all formatters are used regardless of config.
   *
   * @param entryPath - Path to the entry file
   * @returns Compilation result with all formatter outputs
   */
  async compileAll(entryPath: string): Promise<CompileResult> {
    // Get all registered formatters
    const allFormatters = FormatterRegistry.list();

    // Create a new compiler with all formatters
    const compiler = new Compiler({
      ...this.options,
      formatters: allFormatters,
    });

    return compiler.compile(entryPath);
  }

  /**
   * Watch for file changes and recompile automatically.
   *
   * @param entryPath - Path to the entry file to compile
   * @param options - Watch options
   * @returns Watcher handle to control the watch process
   *
   * @example
   * ```typescript
   * const watcher = await compiler.watch('./project.prs', {
   *   onCompile: (result) => {
   *     if (result.success) {
   *       console.log('Compiled successfully');
   *     }
   *   },
   * });
   *
   * // Later, stop watching
   * await watcher.close();
   * ```
   */
  async watch(entryPath: string, options: WatchOptions = {}): Promise<Watcher> {
    // Dynamic import of chokidar to avoid bundling issues
    const { default: chokidar } = await import('chokidar');
    const { dirname, resolve } = await import('path');

    const baseDir = dirname(resolve(entryPath));
    const includePatterns = options.include ?? ['**/*.prs'];
    const excludePatterns = options.exclude ?? ['**/node_modules/**'];
    const debounceMs = options.debounce ?? 300;

    // Build watch patterns
    const watchPatterns = includePatterns.map((p) => resolve(baseDir, p));

    let debounceTimer: ReturnType<typeof setTimeout> | null = null;
    let pendingChanges: string[] = [];

    const handleChange = async (changedFiles: string[]): Promise<void> => {
      try {
        const result = await this.compile(entryPath);
        options.onCompile?.(result, changedFiles);
      } catch (error) {
        options.onError?.(error as Error);
      }
    };

    const watcher = chokidar.watch(watchPatterns, {
      ignored: excludePatterns,
      persistent: true,
      ignoreInitial: true,
    });

    watcher.on('change', (path: string) => {
      pendingChanges.push(path);

      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      debounceTimer = setTimeout(() => {
        const files = [...pendingChanges];
        pendingChanges = [];
        handleChange(files);
      }, debounceMs);
    });

    watcher.on('add', (path: string) => {
      pendingChanges.push(path);

      if (debounceTimer) {
        clearTimeout(debounceTimer);
      }

      debounceTimer = setTimeout(() => {
        const files = [...pendingChanges];
        pendingChanges = [];
        handleChange(files);
      }, debounceMs);
    });

    watcher.on('error', (error: unknown) => {
      options.onError?.(error instanceof Error ? error : new Error(String(error)));
    });

    return {
      close: async () => {
        if (debounceTimer) {
          clearTimeout(debounceTimer);
        }
        await watcher.close();
      },
    };
  }

  /**
   * Get format options for a specific target.
   */
  private getFormatOptionsForTarget(
    _targetName: string,
    config?: TargetConfig
  ): import('./types.js').FormatOptions {
    const customConventions = this.options.customConventions;
    const prettierOptions = this.options.prettier;

    const options: import('./types.js').FormatOptions = {
      outputPath: config?.output,
      version: config?.version,
      prettier: prettierOptions,
    };

    const conventionName = config?.convention;

    // Check if it's a custom convention
    if (conventionName && customConventions?.[conventionName]) {
      options.convention = customConventions[conventionName];
    } else if (conventionName) {
      options.convention = conventionName;
    }

    return options;
  }

  /**
   * Load and instantiate formatters from options.
   */
  private loadFormatters(formatters: CompilerOptions['formatters']): LoadedFormatter[] {
    return formatters.map((f) => {
      // String name
      if (typeof f === 'string') {
        return { formatter: this.loadFormatterByName(f) };
      }

      // Check if it's a constructor (function)
      if (typeof f === 'function') {
        return { formatter: new (f as unknown as FormatterConstructor)() };
      }

      // Object with name and config (not a Formatter instance)
      if ('name' in f && typeof f.name === 'string' && !('format' in f)) {
        const configObj = f as { name: string; config?: TargetConfig };
        return {
          formatter: this.loadFormatterByName(configObj.name),
          config: configObj.config,
        };
      }

      // Already a Formatter instance
      return { formatter: f as Formatter };
    });
  }

  /**
   * Dynamically load a formatter by name.
   *
   * Uses the FormatterRegistry to look up registered formatters.
   */
  private loadFormatterByName(name: string): Formatter {
    const formatter = FormatterRegistry.get(name);
    if (formatter) {
      return formatter;
    }
    throw new Error(
      `Unknown formatter: '${name}'. Available formatters: ${FormatterRegistry.list().join(', ')}`
    );
  }

  /**
   * Convert any error to a CompileError.
   */
  private toCompileError(err: Error | PSError): CompileError {
    const psError = err as PSError;

    return {
      name: err.name,
      code: psError.code ?? 'PS0000',
      message: err.message,
      location: psError.location
        ? {
            file: psError.location.file,
            line: psError.location.line,
            column: psError.location.column,
          }
        : undefined,
      format: psError.format ? () => psError.format() : undefined,
    };
  }

  /**
   * Convert a validation message to a CompileError.
   */
  private validationToCompileError(
    msg: import('@promptscript/validator').ValidationMessage
  ): CompileError {
    return {
      name: 'ValidationError',
      code: msg.ruleId,
      message: msg.message,
      location: msg.location
        ? {
            file: msg.location.file,
            line: msg.location.line,
            column: msg.location.column,
          }
        : undefined,
    };
  }
}

/**
 * Create a new compiler instance.
 *
 * @param options - Compiler options
 * @returns New Compiler instance
 */
export function createCompiler(options: CompilerOptions): Compiler {
  return new Compiler(options);
}

/**
 * Options for the standalone compile function.
 */
export interface CompileOptions {
  /**
   * Resolver options for resolving imports and inheritance.
   * If not provided, defaults to current working directory.
   */
  resolver?: {
    /** Base path for registry lookups (@namespace/...). Defaults to cwd. */
    registryPath?: string;
    /** Base path for local/relative file resolution. Defaults to cwd. */
    localPath?: string;
    /** Whether to cache resolved ASTs. Defaults to true. */
    cache?: boolean;
  };
  /**
   * Validator configuration.
   */
  validator?: ValidatorConfig;
  /**
   * Formatters to use. If not specified, all built-in formatters are used.
   */
  formatters?: CompilerOptions['formatters'];
  /**
   * Custom conventions for formatters.
   */
  customConventions?: CompilerOptions['customConventions'];
  /**
   * Prettier formatting options for markdown output.
   */
  prettier?: CompilerOptions['prettier'];
}

/**
 * Compile a PromptScript file using default or specified options.
 *
 * This is a convenience function that creates a Compiler instance
 * and runs the compilation pipeline. For repeated compilations,
 * consider creating a Compiler instance directly for better performance.
 *
 * @param entryPath - Path to the entry PromptScript file
 * @param options - Optional compilation options
 * @returns Compilation result with outputs, errors, and stats
 *
 * @example
 * ```typescript
 * import { compile } from '@promptscript/compiler';
 *
 * // Simple usage with defaults
 * const result = await compile('./project.prs');
 *
 * // With custom options
 * const result = await compile('./project.prs', {
 *   formatters: ['github', 'claude'],
 *   resolver: { registryPath: './registry' },
 * });
 *
 * if (result.success) {
 *   for (const [path, output] of result.outputs) {
 *     console.log(`Generated: ${path}`);
 *   }
 * }
 * ```
 */
export async function compile(
  entryPath: string,
  options: CompileOptions = {}
): Promise<CompileResult> {
  // Get default formatters from registry if not specified
  const formatters: CompilerOptions['formatters'] = options.formatters ?? FormatterRegistry.list();

  // Build resolver options with sensible defaults
  const resolverOptions = {
    registryPath: options.resolver?.registryPath ?? process.cwd(),
    localPath: options.resolver?.localPath,
    cache: options.resolver?.cache,
  };

  const compiler = new Compiler({
    resolver: resolverOptions,
    validator: options.validator,
    formatters,
    customConventions: options.customConventions,
    prettier: options.prettier,
  });

  return compiler.compile(entryPath);
}
