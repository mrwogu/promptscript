import { resolve, dirname } from 'path';
import { writeFile, mkdir, readFile } from 'fs/promises';
import { existsSync } from 'fs';
import chokidar from 'chokidar';
import type { CompileOptions } from '../types.js';
import type { Logger, PromptScriptConfig, TargetEntry, TargetConfig } from '@promptscript/core';
import type { CompileResult, FormatterOutput } from '@promptscript/compiler';
import { loadConfig } from '../config/loader.js';
import { resolvePrettierOptions } from '../prettier/loader.js';
import { createSpinner, ConsoleOutput, isVerbose, isDebug } from '../output/console.js';
import { Compiler } from '@promptscript/compiler';
import { isTTY } from '../output/pager.js';
import { type CliServices, createDefaultServices } from '../services.js';
import { resolveRegistryPath } from '../utils/registry-resolver.js';

/**
 * Markers that identify files generated by PromptScript.
 * We check the first 10 lines of a file for any of these markers.
 */
const PROMPTSCRIPT_MARKERS = [
  '<!-- PromptScript', // Current marker (HTML comment with date)
  '> Auto-generated by PromptScript', // Legacy - for backwards compatibility
];

/**
 * Regex to match PromptScript marker lines for content comparison.
 * Matches both current format (<!-- PromptScript TIMESTAMP - do not edit -->)
 * and captures trailing newlines for clean removal.
 */
const MARKER_REGEX = /<!-- PromptScript [^>]+ -->\n*/g;

/**
 * Strip PromptScript markers from content for comparison purposes.
 * This allows comparing actual content changes while ignoring timestamp updates.
 */
function stripMarkers(content: string): string {
  return content.replace(MARKER_REGEX, '');
}

/**
 * Create a logger that outputs to ConsoleOutput based on log level.
 */
function createCliLogger(): Logger {
  return {
    verbose: (message: string) => {
      if (isVerbose() || isDebug()) {
        ConsoleOutput.verbose(message);
      }
    },
    debug: (message: string) => {
      if (isDebug()) {
        ConsoleOutput.debug(message);
      }
    },
  };
}

/**
 * Parse target entries into compiler format.
 * Filters out targets with enabled: false.
 */
function parseTargets(targets: TargetEntry[]): { name: string; config?: TargetConfig }[] {
  return targets
    .map((entry) => {
      if (typeof entry === 'string') {
        return { name: entry };
      }
      // Object format: { github: { convention: 'xml' } }
      const entries = Object.entries(entry);
      if (entries.length === 0) {
        throw new Error('Empty target configuration');
      }
      const [name, config] = entries[0] as [string, TargetConfig | undefined];
      return { name, config };
    })
    .filter((target) => target.config?.enabled !== false);
}

/**
 * Check if a file was generated by PromptScript by looking for markers in the first 20 lines.
 * Extended from 10 to 20 to handle skill files with extended YAML frontmatter.
 */
async function isPromptScriptGenerated(filePath: string): Promise<boolean> {
  try {
    const content = await readFile(filePath, 'utf-8');
    const lines = content.split('\n').slice(0, 20);
    return lines.some((line) => PROMPTSCRIPT_MARKERS.some((marker) => line.includes(marker)));
  } catch {
    // File doesn't exist or can't be read - treat as not generated
    return false;
  }
}

/**
 * User response when prompted about overwriting a file.
 */
type OverwriteResponse = 'yes' | 'no' | 'all';

/**
 * Prompt the user about overwriting a file.
 * Returns 'yes' to overwrite this file, 'no' to skip, 'all' to overwrite all remaining.
 */
async function promptForOverwrite(
  filePath: string,
  services: CliServices
): Promise<OverwriteResponse> {
  const response = await services.prompts.select({
    message: `File exists and was not generated by PromptScript: ${filePath}\nOverwrite?`,
    choices: [
      { name: 'No (skip this file)', value: 'no' as const },
      { name: 'Yes (overwrite this file)', value: 'yes' as const },
      { name: 'All (overwrite all remaining files)', value: 'all' as const },
    ],
    default: 'no' as const,
  });
  return response;
}

/**
 * Result of writing outputs.
 */
interface WriteResult {
  written: string[];
  skipped: string[];
  unchanged: string[];
}

/**
 * Print compilation errors to console.
 */
function printErrors(errors: CompileResult['errors']): void {
  for (const err of errors) {
    ConsoleOutput.error(err.message);
    if (err.location) {
      ConsoleOutput.muted(`at ${err.location.file}:${err.location.line}:${err.location.column}`);
    }
  }
}

/**
 * Write output files to disk or show dry-run preview.
 * Handles overwrite protection for user files.
 */
async function writeOutputs(
  outputs: Map<string, FormatterOutput>,
  options: CompileOptions,
  _config: PromptScriptConfig,
  services: CliServices
): Promise<WriteResult> {
  const result: WriteResult = { written: [], skipped: [], unchanged: [] };
  let overwriteAll = false;
  const conflicts: string[] = [];

  for (const output of outputs.values()) {
    const outputPath = options.output ? resolve(options.output, output.path) : resolve(output.path);

    // Check if file exists
    const fileExists = existsSync(outputPath);

    if (options.dryRun) {
      // In dry-run mode, show what would happen
      if (fileExists) {
        const isGenerated = await isPromptScriptGenerated(outputPath);
        if (isGenerated) {
          // Check if content would actually change
          const existingContent = await readFile(outputPath, 'utf-8');
          const existingWithoutMarker = stripMarkers(existingContent);
          const newWithoutMarker = stripMarkers(output.content);

          if (existingWithoutMarker === newWithoutMarker) {
            ConsoleOutput.dryRun(`Unchanged: ${outputPath}`);
            result.unchanged.push(outputPath);
          } else {
            ConsoleOutput.dryRun(`Would overwrite: ${outputPath}`);
            result.written.push(outputPath);
          }
        } else {
          ConsoleOutput.warning(`Would conflict: ${outputPath} (not generated by PromptScript)`);
          result.written.push(outputPath);
        }
      } else {
        ConsoleOutput.dryRun(`Would write: ${outputPath}`);
        result.written.push(outputPath);
      }
      continue;
    }

    // File doesn't exist - write normally
    if (!fileExists) {
      await mkdir(dirname(outputPath), { recursive: true });
      await writeFile(outputPath, output.content, 'utf-8');
      ConsoleOutput.success(outputPath);
      result.written.push(outputPath);
      continue;
    }

    // File exists - check if it was generated by PromptScript
    const isGenerated = await isPromptScriptGenerated(outputPath);

    if (isGenerated) {
      // Compare content without markers to avoid unnecessary writes
      const existingContent = await readFile(outputPath, 'utf-8');
      const existingWithoutMarker = stripMarkers(existingContent);
      const newWithoutMarker = stripMarkers(output.content);

      if (existingWithoutMarker === newWithoutMarker) {
        // Content unchanged - skip writing to preserve original timestamp
        ConsoleOutput.unchanged(outputPath);
        result.unchanged.push(outputPath);
        continue;
      }

      // Content changed - write with new marker
      await mkdir(dirname(outputPath), { recursive: true });
      await writeFile(outputPath, output.content, 'utf-8');
      ConsoleOutput.success(outputPath);
      result.written.push(outputPath);
      continue;
    }

    // File exists and was NOT generated by PromptScript
    // Check for --force flag or overwriteAll state
    if (options.force || overwriteAll) {
      await mkdir(dirname(outputPath), { recursive: true });
      await writeFile(outputPath, output.content, 'utf-8');
      ConsoleOutput.success(outputPath);
      result.written.push(outputPath);
      continue;
    }

    // Check if we're in an interactive terminal
    if (!isTTY()) {
      // Non-interactive mode - collect conflicts for error
      conflicts.push(outputPath);
      continue;
    }

    // Interactive mode - prompt user
    const response = await promptForOverwrite(outputPath, services);

    switch (response) {
      case 'yes':
        await mkdir(dirname(outputPath), { recursive: true });
        await writeFile(outputPath, output.content, 'utf-8');
        ConsoleOutput.success(outputPath);
        result.written.push(outputPath);
        break;
      case 'no':
        ConsoleOutput.skipped(outputPath);
        result.skipped.push(outputPath);
        break;
      case 'all':
        overwriteAll = true;
        await mkdir(dirname(outputPath), { recursive: true });
        await writeFile(outputPath, output.content, 'utf-8');
        ConsoleOutput.success(outputPath);
        result.written.push(outputPath);
        break;
    }
  }

  // If there were conflicts in non-interactive mode, fail with error
  if (conflicts.length > 0) {
    const fileList = conflicts.map((f) => `  - ${f}`).join('\n');
    throw new Error(
      `Cannot overwrite files not generated by PromptScript in non-interactive mode:\n${fileList}\n\nUse --force to overwrite these files.`
    );
  }

  return result;
}

/**
 * Print compilation stats.
 */
function printStats(stats: CompileResult['stats']): void {
  ConsoleOutput.newline();
  ConsoleOutput.stats(
    `Stats: ${stats.totalTime}ms ` +
      `(resolve: ${stats.resolveTime}ms, ` +
      `validate: ${stats.validateTime}ms, ` +
      `format: ${stats.formatTime}ms)`
  );
}

/**
 * Print compilation warnings.
 */
function printWarnings(warnings: CompileResult['warnings']): void {
  if (warnings.length > 0) {
    ConsoleOutput.newline();
    console.log(`Warnings (${warnings.length}):`);
    for (const warn of warnings) {
      ConsoleOutput.warning(`${warn.ruleId}: ${warn.message}`);
    }
  }
}

/**
 * Compile PromptScript files to target formats.
 */
export async function compileCommand(
  options: CompileOptions,
  services: CliServices = createDefaultServices()
): Promise<void> {
  const spinner = createSpinner('Loading configuration...').start();
  const logger = createCliLogger();

  try {
    logger.verbose('Loading configuration...');
    const config = await loadConfig(options.config);

    // --format is an alias for --target
    const selectedTarget = options.target ?? options.format;
    const targets = selectedTarget ? [{ name: selectedTarget }] : parseTargets(config.targets);

    // Resolve registry path - use CLI flag override, or resolve from config (handles git registries)
    let registryPath: string;
    if (options.registry) {
      registryPath = options.registry;
    } else {
      spinner.text = 'Resolving registry...';
      const registry = await resolveRegistryPath(config);
      registryPath = registry.path;
      if (registry.isRemote) {
        logger.verbose(`Using cached git registry: ${registryPath}`);
      }
    }

    spinner.text = 'Compiling...';
    logger.verbose(`Registry: ${registryPath}`);
    logger.debug(`Config: ${JSON.stringify(config, null, 2)}`);

    // Resolve Prettier options from config
    const prettierOptions = await resolvePrettierOptions(config, process.cwd());

    const compiler = new Compiler({
      resolver: {
        registryPath,
        localPath: './.promptscript',
      },
      validator: config.validation,
      formatters: targets,
      customConventions: config.customConventions,
      prettier: prettierOptions,
      logger,
    });

    const entryPath = resolve('./.promptscript/project.prs');

    if (!existsSync(entryPath)) {
      spinner.fail('Entry file not found');
      ConsoleOutput.error(`File not found: ${entryPath}`);
      ConsoleOutput.muted('Run: prs init');
      process.exit(1);
    }

    const result = await compiler.compile(entryPath);

    if (!result.success) {
      spinner.fail('Compilation failed');
      ConsoleOutput.newline();
      printErrors(result.errors);
      process.exit(1);
    }

    spinner.succeed('Compilation successful');
    ConsoleOutput.newline();

    const writeResult = await writeOutputs(result.outputs, options, config, services);
    if (writeResult.unchanged.length > 0) {
      ConsoleOutput.muted(`Unchanged ${writeResult.unchanged.length} file(s)`);
    }
    if (writeResult.skipped.length > 0) {
      ConsoleOutput.muted(`Skipped ${writeResult.skipped.length} file(s)`);
    }
    printStats(result.stats);
    printWarnings(result.warnings);

    // Watch mode
    if (options.watch) {
      ConsoleOutput.newline();
      ConsoleOutput.info('Watching for changes... (Ctrl+C to stop)');
      watchForChanges('./.promptscript', () =>
        compileCommand({ ...options, watch: false }, services)
      );
    }
  } catch (error) {
    if ((error as Error).name === 'ExitPromptError') {
      // User cancelled with Ctrl+C during prompt
      spinner.stop();
      ConsoleOutput.newline();
      ConsoleOutput.muted('Compilation cancelled');
      return;
    }
    spinner.fail('Error');
    ConsoleOutput.error((error as Error).message);
    process.exit(1);
  }
}

/**
 * Watch directory for changes using chokidar and trigger recompilation.
 *
 * Uses chokidar for better cross-platform support and reliability compared
 * to native fs.watch.
 */
function watchForChanges(dir: string, callback: () => void): void {
  let debounceTimer: NodeJS.Timeout | null = null;
  const debounceMs = 100;

  const watcher = chokidar.watch(`${dir}/**/*.prs`, {
    persistent: true,
    ignoreInitial: true,
    awaitWriteFinish: {
      stabilityThreshold: 50,
      pollInterval: 10,
    },
  });

  watcher.on('change', (filename) => {
    // Debounce rapid changes
    if (debounceTimer) {
      clearTimeout(debounceTimer);
    }

    debounceTimer = setTimeout(() => {
      ConsoleOutput.newline();
      ConsoleOutput.info(`File changed: ${filename}`);
      callback();
    }, debounceMs);
  });

  watcher.on('add', (filename) => {
    ConsoleOutput.info(`File added: ${filename}`);
    callback();
  });

  watcher.on('unlink', (filename) => {
    ConsoleOutput.info(`File removed: ${filename}`);
  });

  watcher.on('error', (error: unknown) => {
    const errorMessage = error instanceof Error ? error.message : String(error);
    ConsoleOutput.error(`Watcher error: ${errorMessage}`);
  });
}
