import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest';
import { resolve } from 'path';
import type { CliServices } from '../services.js';

// Mock the compiler module - using vi.hoisted to access the mock in vi.mock
const {
  mockCompile,
  MockCompiler,
  mockWriteFile,
  mockMkdir,
  mockReadFile,
  mockExistsSync,
  mockIsTTY,
  mockLoadConfig,
} = vi.hoisted(() => {
  const mockCompile = vi.fn();
  const mockWriteFile = vi.fn();
  const mockMkdir = vi.fn();
  const mockReadFile = vi.fn();
  const mockExistsSync = vi.fn();
  const mockIsTTY = vi.fn();
  const mockLoadConfig = vi.fn();
  return {
    mockCompile,
    MockCompiler: class {
      compile = mockCompile;
    },
    mockWriteFile,
    mockMkdir,
    mockReadFile,
    mockExistsSync,
    mockIsTTY,
    mockLoadConfig,
  };
});

vi.mock('@promptscript/compiler', () => ({
  Compiler: MockCompiler,
}));

// Mock the config loader
vi.mock('../config/loader.js', () => ({
  loadConfig: () => mockLoadConfig(),
}));

// Mock fs/promises
vi.mock('fs/promises', () => ({
  writeFile: (...args: unknown[]) => mockWriteFile(...args),
  mkdir: (...args: unknown[]) => mockMkdir(...args),
  readFile: (...args: unknown[]) => mockReadFile(...args),
  readdir: vi.fn().mockResolvedValue([]),
}));

// Mock prettier loader
vi.mock('../prettier/loader.js', () => ({
  resolvePrettierOptions: vi.fn().mockResolvedValue({}),
}));

// Mock ora
vi.mock('ora', () => ({
  default: vi.fn().mockReturnValue({
    start: vi.fn().mockReturnThis(),
    succeed: vi.fn().mockReturnThis(),
    fail: vi.fn().mockReturnThis(),
    stop: vi.fn().mockReturnThis(),
    text: '',
  }),
}));

// Mock chalk
vi.mock('chalk', () => ({
  default: {
    green: (s: string) => s,
    red: (s: string) => s,
    yellow: (s: string) => s,
    blue: (s: string) => s,
    gray: (s: string) => s,
  },
}));

// Mock process.exit
const mockExit = vi.spyOn(process, 'exit').mockImplementation(() => {
  throw new Error('process.exit called');
});

// Mock fs.existsSync for the entry file check
vi.mock('fs', () => ({
  existsSync: (...args: unknown[]) => mockExistsSync(...args),
  readFileSync: vi.fn().mockReturnValue(''),
}));

// Mock pager for isTTY
vi.mock('../output/pager.js', () => ({
  isTTY: () => mockIsTTY(),
}));

// Import after mocks are set up
import { compileCommand } from '../commands/compile.js';

const PROMPTSCRIPT_MARKER = '> Auto-generated by PromptScript';

describe('compile command - overwrite protection', () => {
  let consoleSpy: ReturnType<typeof vi.spyOn>;
  let consoleErrorSpy: ReturnType<typeof vi.spyOn>;
  let mockPrompts: {
    input: ReturnType<typeof vi.fn>;
    confirm: ReturnType<typeof vi.fn>;
    checkbox: ReturnType<typeof vi.fn>;
    select: ReturnType<typeof vi.fn>;
  };
  let mockServices: CliServices;

  const defaultConfig = {
    targets: ['claude'],
    registry: { path: './registry' },
  };

  const createMockOutput = (path: string, content: string) => ({
    path,
    content,
    target: 'claude',
  });

  beforeEach(() => {
    vi.clearAllMocks();
    consoleSpy = vi.spyOn(console, 'log').mockImplementation(() => {});
    consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

    // Reset fs/promises mocks
    mockWriteFile.mockResolvedValue(undefined);
    mockMkdir.mockResolvedValue(undefined);
    mockReadFile.mockResolvedValue('');

    mockPrompts = {
      input: vi.fn().mockResolvedValue(''),
      confirm: vi.fn().mockResolvedValue(false),
      checkbox: vi.fn().mockResolvedValue([]),
      select: vi.fn().mockResolvedValue('no'),
    };

    mockServices = {
      fs: {
        existsSync: vi.fn(),
        writeFile: vi.fn(),
        mkdir: vi.fn(),
        readFile: vi.fn(),
        readdir: vi.fn(),
        readFileSync: vi.fn(),
      } as unknown as CliServices['fs'],
      prompts: mockPrompts as unknown as CliServices['prompts'],
      cwd: '/mock/project',
    };

    // Default: entry file exists, other files don't
    mockExistsSync.mockImplementation((path: string) => {
      if (path.includes('project.prs')) {
        return true;
      }
      return false;
    });

    mockLoadConfig.mockResolvedValue(defaultConfig);

    // Default: isTTY returns true (interactive mode)
    mockIsTTY.mockReturnValue(true);
  });

  afterEach(() => {
    consoleSpy.mockRestore();
    consoleErrorSpy.mockRestore();
  });

  describe('when file does not exist', () => {
    it('should write file normally without prompting', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      // File does not exist
      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        return false;
      });

      await compileCommand({}, mockServices);

      expect(mockWriteFile).toHaveBeenCalledWith(resolve('CLAUDE.md'), 'content', 'utf-8');
      expect(mockPrompts.select).not.toHaveBeenCalled();
    });
  });

  describe('when file exists with PromptScript marker', () => {
    it('should overwrite silently without prompting', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      // File exists
      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      // File contains PromptScript marker
      mockReadFile.mockResolvedValue(`# Some header\n${PROMPTSCRIPT_MARKER}\n\nOld content`);

      await compileCommand({}, mockServices);

      expect(mockWriteFile).toHaveBeenCalledWith(resolve('CLAUDE.md'), 'new content', 'utf-8');
      expect(mockPrompts.select).not.toHaveBeenCalled();
    });
  });

  describe('when file exists without PromptScript marker', () => {
    beforeEach(() => {
      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      // File does NOT contain PromptScript marker
      mockReadFile.mockResolvedValue('# My custom rules\n\nCustom content');
    });

    describe('in interactive mode', () => {
      beforeEach(() => {
        mockIsTTY.mockReturnValue(true);
      });

      it('should prompt user and skip file when user selects no', async () => {
        const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')]]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        mockPrompts.select.mockResolvedValue('no');

        await compileCommand({}, mockServices);

        expect(mockPrompts.select).toHaveBeenCalledTimes(1);
        expect(mockWriteFile).not.toHaveBeenCalled();
        // Should show skipped message
        expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('âŠ˜'));
      });

      it('should prompt user and overwrite file when user selects yes', async () => {
        const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')]]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        mockPrompts.select.mockResolvedValue('yes');

        await compileCommand({}, mockServices);

        expect(mockPrompts.select).toHaveBeenCalledTimes(1);
        expect(mockWriteFile).toHaveBeenCalledWith(resolve('CLAUDE.md'), 'new content', 'utf-8');
      });

      it('should overwrite all remaining files when user selects all', async () => {
        const outputs = new Map([
          ['CLAUDE.md', createMockOutput('CLAUDE.md', 'content1')],
          ['AGENTS.md', createMockOutput('AGENTS.md', 'content2')],
          ['rules.md', createMockOutput('rules.md', 'content3')],
        ]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        // All files exist without marker
        mockExistsSync.mockImplementation((path: string) => {
          if (path.includes('project.prs')) return true;
          return true; // All output files exist
        });

        // First prompt: select 'all'
        mockPrompts.select.mockResolvedValue('all');

        await compileCommand({}, mockServices);

        // Should only prompt once (for the first file)
        expect(mockPrompts.select).toHaveBeenCalledTimes(1);
        // All files should be written
        expect(mockWriteFile).toHaveBeenCalledTimes(3);
      });

      it('should handle mixed responses (yes, no, all)', async () => {
        const outputs = new Map([
          ['file1.md', createMockOutput('file1.md', 'content1')],
          ['file2.md', createMockOutput('file2.md', 'content2')],
          ['file3.md', createMockOutput('file3.md', 'content3')],
        ]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        mockExistsSync.mockImplementation((path: string) => {
          if (path.includes('project.prs')) return true;
          return true;
        });

        // First: yes, Second: no
        mockPrompts.select
          .mockResolvedValueOnce('yes')
          .mockResolvedValueOnce('no')
          .mockResolvedValueOnce('yes');

        await compileCommand({}, mockServices);

        expect(mockPrompts.select).toHaveBeenCalledTimes(3);
        expect(mockWriteFile).toHaveBeenCalledTimes(2); // Only 2 files written
      });
    });

    describe('in non-interactive mode', () => {
      beforeEach(() => {
        mockIsTTY.mockReturnValue(false);
      });

      it('should fail with error listing conflicts', async () => {
        const outputs = new Map([
          ['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')],
          ['AGENTS.md', createMockOutput('AGENTS.md', 'other content')],
        ]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        mockExistsSync.mockImplementation((path: string) => {
          if (path.includes('project.prs')) return true;
          return true; // All files exist
        });

        await expect(compileCommand({}, mockServices)).rejects.toThrow('process.exit called');

        expect(mockExit).toHaveBeenCalledWith(1);
        expect(consoleErrorSpy).toHaveBeenCalledWith(
          expect.stringContaining('Cannot overwrite files not generated by PromptScript')
        );
        expect(mockPrompts.select).not.toHaveBeenCalled();
      });
    });

    describe('with --force flag', () => {
      it('should overwrite without prompting', async () => {
        const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')]]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        await compileCommand({ force: true }, mockServices);

        expect(mockPrompts.select).not.toHaveBeenCalled();
        expect(mockWriteFile).toHaveBeenCalledWith(resolve('CLAUDE.md'), 'new content', 'utf-8');
      });

      it('should work in non-interactive mode with --force', async () => {
        mockIsTTY.mockReturnValue(false);

        const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'new content')]]);

        mockCompile.mockResolvedValue({
          success: true,
          outputs,
          stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
          warnings: [],
          errors: [],
        });

        await compileCommand({ force: true }, mockServices);

        expect(mockWriteFile).toHaveBeenCalled();
        expect(mockExit).not.toHaveBeenCalled();
      });
    });
  });

  describe('with --dry-run flag', () => {
    it('should show what would happen for new files', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        return false;
      });

      await compileCommand({ dryRun: true }, mockServices);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Would write:'));
      expect(mockWriteFile).not.toHaveBeenCalled();
      expect(mockPrompts.select).not.toHaveBeenCalled();
    });

    it('should show overwrite for PromptScript-generated files', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      mockReadFile.mockResolvedValue(`${PROMPTSCRIPT_MARKER}\ncontent`);

      await compileCommand({ dryRun: true }, mockServices);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Would overwrite:'));
      expect(mockWriteFile).not.toHaveBeenCalled();
    });

    it('should show conflict warning for non-PromptScript files', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      mockReadFile.mockResolvedValue('# Custom rules');

      await compileCommand({ dryRun: true }, mockServices);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Would conflict:'));
      expect(mockWriteFile).not.toHaveBeenCalled();
      expect(mockPrompts.select).not.toHaveBeenCalled();
    });
  });

  describe('user cancellation (Ctrl+C)', () => {
    it('should handle ExitPromptError gracefully', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      mockReadFile.mockResolvedValue('# Custom rules');

      const exitPromptError = new Error('User cancelled');
      exitPromptError.name = 'ExitPromptError';
      mockPrompts.select.mockRejectedValue(exitPromptError);

      // Should not throw
      await compileCommand({}, mockServices);

      expect(mockWriteFile).not.toHaveBeenCalled();
      expect(mockExit).not.toHaveBeenCalled();
      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Compilation cancelled'));
    });
  });

  describe('PromptScript marker detection', () => {
    it('should detect marker in first 10 lines', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      // Marker on line 9 (within first 10 lines)
      const lines = Array(8).fill('# Some content');
      lines.push(PROMPTSCRIPT_MARKER);
      mockReadFile.mockResolvedValue(lines.join('\n'));

      await compileCommand({}, mockServices);

      // Should overwrite without prompt since marker is present
      expect(mockPrompts.select).not.toHaveBeenCalled();
      expect(mockWriteFile).toHaveBeenCalled();
    });

    it('should NOT detect marker after line 20', async () => {
      const outputs = new Map([['CLAUDE.md', createMockOutput('CLAUDE.md', 'content')]]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        if (path.includes('CLAUDE.md')) return true;
        return false;
      });

      // Marker on line 25 (after first 20 lines)
      const lines = Array(24).fill('# Some content');
      lines.push(PROMPTSCRIPT_MARKER);
      mockReadFile.mockResolvedValue(lines.join('\n'));

      mockPrompts.select.mockResolvedValue('no');

      await compileCommand({}, mockServices);

      // Should prompt because marker is not in first 20 lines
      expect(mockPrompts.select).toHaveBeenCalled();
    });
  });

  describe('skipped files reporting', () => {
    it('should report number of skipped files', async () => {
      const outputs = new Map([
        ['file1.md', createMockOutput('file1.md', 'content1')],
        ['file2.md', createMockOutput('file2.md', 'content2')],
      ]);

      mockCompile.mockResolvedValue({
        success: true,
        outputs,
        stats: { totalTime: 100, resolveTime: 50, validateTime: 25, formatTime: 25 },
        warnings: [],
        errors: [],
      });

      mockExistsSync.mockImplementation((path: string) => {
        if (path.includes('project.prs')) return true;
        return true;
      });

      mockReadFile.mockResolvedValue('# Custom content');
      mockPrompts.select.mockResolvedValue('no');

      await compileCommand({}, mockServices);

      expect(consoleSpy).toHaveBeenCalledWith(expect.stringContaining('Skipped 2 file(s)'));
    });
  });
});
