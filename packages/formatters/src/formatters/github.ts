import type { Program, Value } from '@promptscript/core';
import { BaseFormatter } from '../base-formatter';
import type { FormatterOutput } from '../types';

/**
 * Formatter for GitHub Copilot instructions.
 * Outputs: `.github/copilot-instructions.md`
 */
export class GitHubFormatter extends BaseFormatter {
  readonly name = 'github';
  readonly outputPath = '.github/copilot-instructions.md';
  readonly description = 'GitHub Copilot instructions (Markdown)';

  format(ast: Program): FormatterOutput {
    const sections: string[] = [];

    sections.push(this.header(ast));

    const context = this.context(ast);
    if (context) sections.push(context);

    const techStack = this.techStack(ast);
    if (techStack) sections.push(techStack);

    const standards = this.standards(ast);
    if (standards) sections.push(standards);

    const restrictions = this.restrictions(ast);
    if (restrictions) sections.push(restrictions);

    const commands = this.commands(ast);
    if (commands) sections.push(commands);

    return {
      path: this.outputPath,
      content: sections.join('\n\n---\n\n'),
    };
  }

  private header(ast: Program): string {
    const id = this.getMetaField(ast, 'id') ?? 'unknown';
    const version = this.getMetaField(ast, 'version') ?? '0.0.0';

    return `# GitHub Copilot Instructions

> Auto-generated by PromptScript
> Source: ${id}@${version}
> Generated: ${new Date().toISOString()}
>
> **Do not edit manually**`;
  }

  private context(ast: Program): string | null {
    const identity = this.findBlock(ast, 'identity');
    const context = this.findBlock(ast, 'context');

    if (!identity && !context) return null;

    let content = '## Context\n\n';

    if (identity) {
      content += this.extractText(identity.content) + '\n\n';
    }

    if (context) {
      const text = this.extractText(context.content);
      if (text) {
        content += text;
      } else {
        // Format context as properties
        const props = this.getProps(context.content);
        for (const [key, value] of Object.entries(props)) {
          content += `**${this.capitalize(key)}:** ${this.valueToString(value)}\n`;
        }
      }
    }

    return content.trim();
  }

  private techStack(ast: Program): string | null {
    const standards = this.findBlock(ast, 'standards');
    if (!standards) return null;

    const code = this.getProp(standards.content, 'code');
    if (!code || typeof code !== 'object' || Array.isArray(code)) return null;

    const codeObj = code as Record<string, Value>;
    const parts = ['## Tech Stack\n'];

    const languages = codeObj['languages'];
    if (languages) {
      const arr = Array.isArray(languages) ? languages : [languages];
      parts.push(`- **Languages:** ${this.formatArray(arr)}`);
    }

    const frameworks = codeObj['frameworks'];
    if (frameworks) {
      const arr = Array.isArray(frameworks) ? frameworks : [frameworks];
      parts.push(`- **Frameworks:** ${this.formatArray(arr)}`);
    }

    const testing = codeObj['testing'];
    if (testing) {
      const arr = Array.isArray(testing) ? testing : [testing];
      parts.push(`- **Testing:** ${this.formatArray(arr)}`);
    }

    return parts.length > 1 ? parts.join('\n') : null;
  }

  private standards(ast: Program): string | null {
    const block = this.findBlock(ast, 'standards');
    if (!block) return null;

    const props = this.getProps(block.content);
    if (Object.keys(props).length === 0) return null;

    let content = '## Code Standards\n\n';

    const codeContent = this.formatCodeStandards(props['code']);
    if (codeContent) content += codeContent;

    const testingContent = this.formatTestingStandards(props['testing']);
    if (testingContent) content += testingContent;

    return content.trim();
  }

  private formatCodeStandards(code: Value | undefined): string {
    if (!code || typeof code !== 'object' || Array.isArray(code)) return '';

    const codeObj = code as Record<string, Value>;
    let content = '';

    content += this.formatListSection('Style', codeObj['style']);
    content += this.formatListSection('Patterns', codeObj['patterns']);

    return content;
  }

  private formatListSection(title: string, items: Value | undefined): string {
    if (!items) return '';

    let content = `### ${title}\n`;
    const itemsArray = Array.isArray(items) ? items : [items];

    for (const item of itemsArray) {
      content += `- ${this.valueToString(item)}\n`;
    }

    return content + '\n';
  }

  private formatTestingStandards(testing: Value | undefined): string {
    if (!testing || typeof testing !== 'object' || Array.isArray(testing)) {
      return '';
    }

    const testObj = testing as Record<string, Value>;
    let content = '### Testing\n';

    const required = testObj['required'];
    if (required !== undefined) {
      content += `- Required: ${required ? 'Yes' : 'No'}\n`;
    }

    const coverage = testObj['coverage'];
    if (coverage !== undefined) {
      content += `- Minimum coverage: ${coverage}%\n`;
    }

    return content + '\n';
  }

  private restrictions(ast: Program): string | null {
    const block = this.findBlock(ast, 'restrictions');
    if (!block) return null;

    if (block.content.type === 'ArrayContent') {
      let content = '## Restrictions\n\n';
      for (const item of block.content.elements) {
        content += `- ${this.valueToString(item)}\n`;
      }
      return content.trim();
    }

    if (block.content.type === 'TextContent') {
      return `## Restrictions\n\n${block.content.value.trim()}`;
    }

    return null;
  }

  private commands(ast: Program): string | null {
    const block = this.findBlock(ast, 'shortcuts');
    if (!block) return null;

    const props = this.getProps(block.content);
    if (Object.keys(props).length === 0) return null;

    let content = '## Commands\n\n| Command | Description |\n|---------|-------------|\n';

    for (const [cmd, desc] of Object.entries(props)) {
      const description = this.truncate(this.valueToString(desc), 60);
      content += `| \`${cmd}\` | ${description} |\n`;
    }

    return content.trim();
  }

  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
